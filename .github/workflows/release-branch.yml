name: Release Branch Management

on:
  # Manual workflow dispatch for creating release branches
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - 'major'
          - 'minor'
          - 'patch'
        default: 'minor'
      custom_version:
        description: 'Custom version (optional, overrides release_type)'
        required: false
        type: string
      source_branch:
        description: 'Source branch for release'
        required: false
        type: string
        default: 'develop'

  # Automatically create release branch when develop is ready
  push:
    branches:
      - develop
    paths:
      - 'package.json'
      - 'CHANGELOG.md'
  
  # Handle release PR events
  pull_request:
    types: [opened, closed]
    branches:
      - main
    paths:
      - 'package.json'

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  # Detect if a release should be created automatically
  detect-release-need:
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    outputs:
      should_create_release: ${{ steps.check.outputs.should_create }}
      next_version: ${{ steps.check.outputs.next_version }}
    steps:
      - name: Checkout develop
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          ref: develop
          fetch-depth: 0

      - name: Check if release is needed
        id: check
        run: |
          # Get current version from package.json
          CURRENT_VERSION=$(jq -r '.version' package.json)
          echo "Current version: $CURRENT_VERSION"
          
          # Check if there are unreleased changes since last release
          LAST_RELEASE_TAG=$(git tag --sort=-version:refname | head -1)
          
          if [ -z "$LAST_RELEASE_TAG" ]; then
            echo "No previous releases found, creating initial release"
            echo "should_create=true" >> $GITHUB_OUTPUT
            echo "next_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check commits since last release
          COMMITS_SINCE_RELEASE=$(git rev-list ${LAST_RELEASE_TAG}..develop --count)
          echo "Commits since last release: $COMMITS_SINCE_RELEASE"
          
          # Check for conventional commit types that warrant a release
          FEAT_COMMITS=$(git log ${LAST_RELEASE_TAG}..develop --oneline | grep -c "^[a-f0-9]* feat" || true)
          FIX_COMMITS=$(git log ${LAST_RELEASE_TAG}..develop --oneline | grep -c "^[a-f0-9]* fix" || true)
          BREAKING_COMMITS=$(git log ${LAST_RELEASE_TAG}..develop --oneline | grep -c "!" || true)
          
          echo "Feature commits: $FEAT_COMMITS"
          echo "Fix commits: $FIX_COMMITS"
          echo "Breaking commits: $BREAKING_COMMITS"
          
          # Determine if release is needed and what type
          if [ $COMMITS_SINCE_RELEASE -gt 0 ] && ([ $FEAT_COMMITS -gt 0 ] || [ $FIX_COMMITS -gt 0 ] || [ $BREAKING_COMMITS -gt 0 ]); then
            echo "Release needed based on commits"
            
            # Determine version bump type
            if [ $BREAKING_COMMITS -gt 0 ]; then
              BUMP_TYPE="major"
            elif [ $FEAT_COMMITS -gt 0 ]; then
              BUMP_TYPE="minor"
            else
              BUMP_TYPE="patch"
            fi
            
            # Calculate next version
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}
            
            case $BUMP_TYPE in
              major)
                NEXT_VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                NEXT_VERSION="${MAJOR}.$((MINOR + 1)).0"
                ;;
              patch)
                NEXT_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
                ;;
            esac
            
            echo "should_create=true" >> $GITHUB_OUTPUT
            echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          else
            echo "No release needed"
            echo "should_create=false" >> $GITHUB_OUTPUT
          fi

  # Create release branch (manual or automatic)
  create-release-branch:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      (needs.detect-release-need.outputs.should_create_release == 'true')
    needs: [detect-release-need]
    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          ref: ${{ github.event.inputs.source_branch || 'develop' }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4.0.3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Determine release version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual workflow
            if [ -n "${{ github.event.inputs.custom_version }}" ]; then
              NEXT_VERSION="${{ github.event.inputs.custom_version }}"
            else
              # Calculate version based on release type
              CURRENT_VERSION=$(jq -r '.version' package.json)
              IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
              MAJOR=${VERSION_PARTS[0]}
              MINOR=${VERSION_PARTS[1]}
              PATCH=${VERSION_PARTS[2]}
              
              case "${{ github.event.inputs.release_type }}" in
                major)
                  NEXT_VERSION="$((MAJOR + 1)).0.0"
                  ;;
                minor)
                  NEXT_VERSION="${MAJOR}.$((MINOR + 1)).0"
                  ;;
                patch)
                  NEXT_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
                  ;;
              esac
            fi
          else
            # Automatic workflow
            NEXT_VERSION="${{ needs.detect-release-need.outputs.next_version }}"
          fi
          
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "branch=release/v$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "Release version: $NEXT_VERSION"

      - name: Check if release branch exists
        id: branch_check
        run: |
          BRANCH="${{ steps.version.outputs.branch }}"
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Release branch $BRANCH already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Release branch $BRANCH does not exist"
          fi

      - name: Create release branch
        if: steps.branch_check.outputs.exists == 'false'
        run: |
          BRANCH="${{ steps.version.outputs.branch }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          # Create and checkout release branch
          git checkout -b "$BRANCH"
          
          # Update version in package.json
          jq --arg version "$VERSION" '.version = $version' package.json > package.json.tmp
          mv package.json.tmp package.json
          
          # Configure git
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Commit version bump
          git add package.json
          git commit -m "chore(release): bump version to v$VERSION"
          
          # Push release branch
          git push origin "$BRANCH"
          
          echo "Created release branch: $BRANCH"

      - name: Create release PR
        if: steps.branch_check.outputs.exists == 'false'
        run: |
          BRANCH="${{ steps.version.outputs.branch }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          # Get changes since last release for PR body
          LAST_TAG=$(git tag --sort=-version:refname | head -1 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            CHANGES=$(git log ${LAST_TAG}..HEAD --oneline --pretty=format:"- %s" | head -20)
          else
            CHANGES=$(git log --oneline --pretty=format:"- %s" | head -20)
          fi
          
          # Create PR body
          PR_BODY="$(cat <<EOF
          ## Release v$VERSION
          
          This PR prepares release v$VERSION for merge to main.
          
          ### Changes since last release:
          $CHANGES
          
          ### Release Checklist:
          - [x] Version bumped in package.json
          - [ ] CHANGELOG.md updated (if applicable)
          - [ ] All CI checks passing
          - [ ] Code review completed
          - [ ] Ready for production deployment
          
          ### Post-merge actions:
          - [ ] Tag will be created automatically
          - [ ] NPM package will be published
          - [ ] Release notes will be generated
          
          ---
          *This PR was created automatically by the release workflow.*
          EOF
          )"
          
          # Create PR using GitHub CLI
          gh pr create \
            --title "Release v$VERSION" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH" \
            --label "release" \
            --label "ready-for-review"
            
          echo "Created release PR for v$VERSION"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Handle release PR merge
  handle-release-merge:
    if: |
      github.event_name == 'pull_request' && 
      github.event.action == 'closed' && 
      github.event.pull_request.merged == true &&
      startsWith(github.event.pull_request.head.ref, 'release/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          ref: main
          fetch-depth: 0

      - name: Extract version from branch name
        id: extract_version
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          VERSION=$(echo "$BRANCH_NAME" | sed 's/release\/v//')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Create release tag
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          
          # Configure git
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Create annotated tag
          git tag -a "v$VERSION" -m "Release v$VERSION"
          git push origin "v$VERSION"
          
          echo "Created and pushed tag: v$VERSION"

      - name: Merge back to develop
        run: |
          # Checkout develop and merge main
          git checkout develop
          git merge main --no-ff -m "chore: merge release v${{ steps.extract_version.outputs.version }} back to develop"
          git push origin develop
          
          echo "Merged release back to develop"

      - name: Clean up release branch
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          git push origin --delete "$BRANCH_NAME"
          echo "Deleted release branch: $BRANCH_NAME"

      - name: Create GitHub release
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          
          # Generate release notes from commits
          LAST_TAG=$(git tag --sort=-version:refname | grep -v "v$VERSION" | head -1 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            CHANGES=$(git log ${LAST_TAG}..v$VERSION --oneline --pretty=format:"- %s")
          else
            CHANGES=$(git log --oneline --pretty=format:"- %s" | head -20)
          fi
          
          # Create release
          gh release create "v$VERSION" \
            --title "Release v$VERSION" \
            --notes "## What's Changed
          
          $CHANGES
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${LAST_TAG}...v$VERSION" \
            --draft=false \
            --prerelease=false
            
          echo "Created GitHub release: v$VERSION"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}