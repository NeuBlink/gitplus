name: Merge Decision

on:
  # Run as a required status check on every PR
  pull_request:
    types: [opened, synchronize, reopened]
  
  # Also run when manually triggered
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to evaluate'
        required: true
        type: number

permissions:
  contents: read
  pull-requests: write
  issues: read
  actions: read
  checks: read
  statuses: write  # Required for creating commit status checks
  id-token: write

jobs:
  wait-for-checks:
    runs-on: ubuntu-latest
    outputs:
      all_checks_complete: ${{ steps.check-status.outputs.all_complete }}
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    steps:
      - name: Get PR number
        id: get-pr
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Wait for other checks to complete
        id: check-status
        run: |
          PR_NUMBER=${{ steps.get-pr.outputs.pr_number }}
          echo "Checking status of PR #$PR_NUMBER"
          
          # Wait up to 30 minutes for checks to complete
          MAX_ATTEMPTS=60
          SLEEP_TIME=30
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i of $MAX_ATTEMPTS"
            
            # Get all check runs for this PR
            CHECKS=$(gh pr checks $PR_NUMBER --repo ${{ github.repository }} --json name,state)
            
            # Check if required checks exist and are complete
            REQUIRED_CHECKS=("claude-review" "test (20.x)" "security" "validate-pr")
            ALL_COMPLETE=true
            ALL_SUCCESS=true
            
            for check in "${REQUIRED_CHECKS[@]}"; do
              CHECK_STATE=$(echo "$CHECKS" | jq -r ".[] | select(.name == \"$check\") | .state // \"not_found\"")
              
              echo "  $check: state=$CHECK_STATE"
              
              if [ "$CHECK_STATE" = "not_found" ] || [ "$CHECK_STATE" = "PENDING" ] || [ "$CHECK_STATE" = "QUEUED" ] || [ "$CHECK_STATE" = "IN_PROGRESS" ]; then
                ALL_COMPLETE=false
              fi
              
              if [ "$CHECK_STATE" != "SUCCESS" ] && [ "$CHECK_STATE" != "not_found" ]; then
                ALL_SUCCESS=false
              fi
            done
            
            if [ "$ALL_COMPLETE" = "true" ]; then
              echo "All required checks have completed"
              echo "all_complete=true" >> $GITHUB_OUTPUT
              echo "all_success=$ALL_SUCCESS" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # Don't sleep on the last attempt
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Waiting $SLEEP_TIME seconds before next check..."
              sleep $SLEEP_TIME
            fi
          done
          
          echo "Timeout waiting for checks to complete"
          echo "all_complete=false" >> $GITHUB_OUTPUT
          exit 1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  merge-decision:
    runs-on: ubuntu-latest
    needs: wait-for-checks
    if: needs.wait-for-checks.outputs.all_checks_complete == 'true'
    
    steps:
      - name: Gather PR context
        id: pr-context
        run: |
          PR_NUMBER=${{ needs.wait-for-checks.outputs.pr_number }}
          echo "Gathering comprehensive PR context for PR #$PR_NUMBER..."
          
          # Get all check results
          echo "CHECK_RESULTS<<EOF" >> $GITHUB_OUTPUT
          gh pr checks $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json name,state,conclusion \
            | jq -r '.[] | "\(.name): \(.state) (\(.conclusion // "pending"))"' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Get PR metadata
          PR_DATA=$(gh pr view $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json title,body,mergeable,mergeStateStatus,isDraft,author,baseRefName,headRefName,commits)
          
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "PR_MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')" >> $GITHUB_OUTPUT
          echo "PR_MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')" >> $GITHUB_OUTPUT
          echo "PR_IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')" >> $GITHUB_OUTPUT
          echo "PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')" >> $GITHUB_OUTPUT
          echo "BASE_BRANCH=$(echo "$PR_DATA" | jq -r '.baseRefName')" >> $GITHUB_OUTPUT
          echo "HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')" >> $GITHUB_OUTPUT
          
          # Check if this is a Release Please PR
          AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
          HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          IS_RELEASE_PLEASE="false"
          if [[ "$AUTHOR" == "app/github-actions" ]] && [[ "$HEAD_BRANCH" == release-please--* ]]; then
            IS_RELEASE_PLEASE="true"
            echo "Detected Release Please PR"
          fi
          echo "IS_RELEASE_PLEASE=$IS_RELEASE_PLEASE" >> $GITHUB_OUTPUT
          
          # Get Claude review comments
          echo "CLAUDE_REVIEWS<<EOF" >> $GITHUB_OUTPUT
          gh pr view $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json comments \
            --jq '.comments[] | select(.author.login == "claude") | .body' \
            | tail -n 1 >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Get specific check states
          TEST_RESULT=$(gh pr checks $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json name,state \
            | jq -r '.[] | select(.name == "test (20.x)") | .state // "PENDING"')
          SECURITY_RESULT=$(gh pr checks $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json name,state \
            | jq -r '.[] | select(.name == "security") | .state // "PENDING"')
          CLAUDE_RESULT=$(gh pr checks $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json name,state \
            | jq -r '.[] | select(.name == "claude-review") | .state // "PENDING"')
          
          echo "TEST_CONCLUSION=$TEST_RESULT" >> $GITHUB_OUTPUT
          echo "SECURITY_CONCLUSION=$SECURITY_RESULT" >> $GITHUB_OUTPUT
          echo "CLAUDE_REVIEW_CONCLUSION=$CLAUDE_RESULT" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Make merge decision
        id: merge-decision
        uses: anthropics/claude-code-action@e26577a930883943cf9d90885cd1e8da510078dd # beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          use_sticky_comment: true
          
          direct_prompt: |
            IMPORTANT: Output ONLY valid JSON. No markdown, no comments, no explanations. ONLY the JSON object.
            
            Context:
            PR Title: ${{ steps.pr-context.outputs.PR_TITLE }}
            Target Branch: ${{ steps.pr-context.outputs.BASE_BRANCH }}
            Author: ${{ steps.pr-context.outputs.PR_AUTHOR }}
            PR Number: #${{ steps.pr-context.outputs.PR_NUMBER }}
            Is Draft: ${{ steps.pr-context.outputs.PR_IS_DRAFT }}
            Is Release Please: ${{ steps.pr-context.outputs.IS_RELEASE_PLEASE }}
            Mergeable: ${{ steps.pr-context.outputs.PR_MERGEABLE }}
            Merge State: ${{ steps.pr-context.outputs.PR_MERGE_STATE }}
            Test Status: ${{ steps.pr-context.outputs.TEST_CONCLUSION }}
            Security Status: ${{ steps.pr-context.outputs.SECURITY_CONCLUSION }}
            Claude Review Status: ${{ steps.pr-context.outputs.CLAUDE_REVIEW_CONCLUSION }}
            
            Claude's Review Comments:
            ${{ steps.pr-context.outputs.CLAUDE_REVIEWS }}
            
            Based on the above, output ONLY this JSON (replace values appropriately):
            {
              "decision": "PASS",
              "confidence": 95,
              "claude_review_verdict": "Claude strongly approved with no blocking issues",
              "checks_status": "All checks passed",
              "blocking_issues": [],
              "warnings": [],
              "summary": "PR approved - Claude review positive and all checks passed"
            }
            
            Rules:
            - decision must be "PASS" or "FAIL" (no other values)
            - For Release Please PRs: PASS if all checks are SUCCESS (tests, security, Claude review)
            - For regular PRs: FAIL if Claude rejected or found blocking issues
            - FAIL if tests or security checks are not SUCCESS
            - FAIL if PR is not mergeable or has conflicts
            - PASS only if Claude approved AND all checks are SUCCESS
            
            OUTPUT ONLY THE JSON OBJECT. NOTHING ELSE.

      - name: Parse and apply decision
        run: |
          set -e  # Exit on error
          
          echo "ðŸ” Waiting for Claude's response (with retries)..."
          
          # Function to fetch Claude response with retries
          fetch_claude_response() {
            local attempt=1
            local max_attempts=5
            local wait_time=15
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Fetching Claude response..."
              
              CLAUDE_RESPONSE=$(gh pr view ${{ steps.pr-context.outputs.PR_NUMBER }} \
                --repo ${{ github.repository }} \
                --json comments \
                --jq '.comments[-1] | select(.author.login == "claude") | .body' 2>/dev/null || echo "")
              
              if [ -n "$CLAUDE_RESPONSE" ] && [ "$CLAUDE_RESPONSE" != "null" ]; then
                echo "âœ… Found Claude response (length: ${#CLAUDE_RESPONSE} chars)"
                echo "ðŸ“ Claude response preview:"
                echo "$CLAUDE_RESPONSE" | head -5
                return 0
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                echo "âŒ No Claude response found, waiting ${wait_time}s before retry..."
                sleep $wait_time
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "âŒ Failed to get Claude response after $max_attempts attempts"
            return 1
          }
          
          # Try to get Claude response
          if ! fetch_claude_response; then
            echo "âš ï¸ Claude response not available, falling back to check-based decision..."
            
            # Fallback: Make decision based on check states only
            if [ "${{ steps.pr-context.outputs.TEST_CONCLUSION }}" = "SUCCESS" ] && \
               [ "${{ steps.pr-context.outputs.SECURITY_CONCLUSION }}" = "SUCCESS" ] && \
               [ "${{ steps.pr-context.outputs.CLAUDE_REVIEW_CONCLUSION }}" = "SUCCESS" ]; then
              DECISION="PASS"
              CONFIDENCE="80"
              SUMMARY="All checks passed (fallback decision - Claude response unavailable)"
            else
              DECISION="FAIL"
              CONFIDENCE="90"
              SUMMARY="Some checks failed (fallback decision - Claude response unavailable)"
            fi
          else
            echo "ðŸ” Parsing Claude response..."
            
            # Advanced JSON extraction with multiple strategies
            extract_json() {
              local response="$1"
              local json=""
              
              # Strategy 1: JSON code block
              json=$(echo "$response" | sed -n '/```json/,/```/p' | grep -v '```' | tr -d '\n' | head -1)
              if [ -n "$json" ] && echo "$json" | jq . >/dev/null 2>&1; then
                echo "$json"
                return 0
              fi
              
              # Strategy 2: Find JSON object
              json=$(echo "$response" | grep -o '{[^{}]*"decision"[^{}]*}' | head -1)
              if [ -n "$json" ] && echo "$json" | jq . >/dev/null 2>&1; then
                echo "$json"
                return 0
              fi
              
              # Strategy 3: Multiline JSON extraction
              json=$(echo "$response" | sed -n '/{/,/}/p' | tr '\n' ' ' | head -1)
              if [ -n "$json" ] && echo "$json" | jq . >/dev/null 2>&1; then
                echo "$json"
                return 0
              fi
              
              # Strategy 4: Look for decision keywords
              if echo "$response" | grep -qi "decision.*PASS"; then
                echo '{"decision":"PASS","confidence":70,"summary":"Parsed from text (PASS found)"}'
                return 0
              elif echo "$response" | grep -qi "decision.*FAIL"; then
                echo '{"decision":"FAIL","confidence":70,"summary":"Parsed from text (FAIL found)"}'
                return 0
              fi
              
              return 1
            }
            
            JSON_RESPONSE=$(extract_json "$CLAUDE_RESPONSE")
            
            if [ -z "$JSON_RESPONSE" ]; then
              echo "âš ï¸ Failed to extract JSON, using fallback decision..."
              DECISION="FAIL"
              CONFIDENCE="50"
              SUMMARY="Could not parse Claude response - manual review needed"
            else
              echo "âœ… Extracted JSON: $JSON_RESPONSE"
              
              # Parse with validation
              DECISION=$(echo "$JSON_RESPONSE" | jq -r '.decision' 2>/dev/null || echo "")
              CONFIDENCE=$(echo "$JSON_RESPONSE" | jq -r '.confidence' 2>/dev/null || echo "0")
              SUMMARY=$(echo "$JSON_RESPONSE" | jq -r '.summary' 2>/dev/null || echo "No summary available")
              
              # Validate extracted values
              if [ -z "$DECISION" ] || [ "$DECISION" = "null" ]; then
                echo "âš ï¸ Invalid decision value, using fallback..."
                DECISION="FAIL"
                CONFIDENCE="50"
                SUMMARY="Invalid Claude response format - manual review needed"
              fi
            fi
          fi
          
          # Normalize confidence
          if [ -z "$CONFIDENCE" ] || [ "$CONFIDENCE" = "null" ] || ! [[ "$CONFIDENCE" =~ ^[0-9]+$ ]]; then
            CONFIDENCE="50"
          fi
          
          echo "ðŸ“Š Final Decision:"
          echo "   Decision: $DECISION"
          echo "   Confidence: $CONFIDENCE%"
          echo "   Summary: $SUMMARY"
          
          # Apply the decision
          if [ "$DECISION" = "PASS" ]; then
            echo "::notice::âœ… Merge Decision: PASS (Confidence: $CONFIDENCE%)"
            echo "::notice::$SUMMARY"
            
            # Auto-merge if this is a Release Please PR
            if [ "${{ steps.pr-context.outputs.IS_RELEASE_PLEASE }}" = "true" ]; then
              echo "::notice::ðŸš€ Auto-merging Release Please PR"
              
              if gh pr merge ${{ steps.pr-context.outputs.PR_NUMBER }} \
                --repo ${{ github.repository }} \
                --auto \
                --squash; then
                echo "âœ… Auto-merge enabled successfully"
              else
                echo "::warning::Failed to enable auto-merge. PR may need manual merge."
              fi
            fi
            
            # Create success status check (non-blocking)
            if gh api repos/${{ github.repository }}/statuses/${{ github.event.pull_request.head.sha || github.sha }} \
              -f state=success \
              -f description="$SUMMARY" \
              -f context="merge-decision" 2>/dev/null; then
              echo "âœ… Success status created"
            else
              echo "::warning::Failed to create success status check, but continuing..."
            fi
            
            exit 0
          else
            echo "::error::âŒ Merge Decision: FAIL (Confidence: $CONFIDENCE%)"
            echo "::error::$SUMMARY"
            
            # Create failure status check (non-blocking)
            if gh api repos/${{ github.repository }}/statuses/${{ github.event.pull_request.head.sha || github.sha }} \
              -f state=failure \
              -f description="$SUMMARY" \
              -f context="merge-decision" 2>/dev/null; then
              echo "âœ… Failure status created"
            else
              echo "::warning::Failed to create failure status check, but continuing..."
            fi
            
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}