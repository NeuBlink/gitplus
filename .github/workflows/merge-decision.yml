name: Merge Decision

on:
  # Run as a required status check on every PR
  pull_request:
    types: [opened, synchronize, reopened]
  
  # Also run when manually triggered
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to evaluate'
        required: true
        type: number

permissions:
  contents: read
  pull-requests: write
  issues: read
  actions: read
  checks: read
  statuses: write  # Required for creating commit status checks
  id-token: write

jobs:
  wait-for-checks:
    runs-on: ubuntu-latest
    outputs:
      all_checks_complete: ${{ steps.check-status.outputs.all_complete }}
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    steps:
      - name: Get PR number
        id: get-pr
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Wait for other checks to complete
        id: check-status
        run: |
          PR_NUMBER=${{ steps.get-pr.outputs.pr_number }}
          echo "Checking status of PR #$PR_NUMBER"
          
          # Wait up to 30 minutes for checks to complete
          MAX_ATTEMPTS=60
          SLEEP_TIME=30
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i of $MAX_ATTEMPTS"
            
            # Get all check runs for this PR
            CHECKS=$(gh pr checks $PR_NUMBER --repo ${{ github.repository }} --json name,state)
            
            # Get all available checks and determine what's actually running
            AVAILABLE_CHECKS=$(echo "$CHECKS" | jq -r '.[].name' | sort)
            echo "Available checks: $(echo "$AVAILABLE_CHECKS" | tr '\n' ', ' | sed 's/,$//')"
            
            # Define preferred checks (in priority order) but be flexible about what exists
            PREFERRED_CHECKS=("claude-review" "test (20.x)" "security" "validate-pr" "CI / test (20.x)")
            REQUIRED_CHECKS=()
            
            # Build list of required checks based on what's actually available
            for check in "${PREFERRED_CHECKS[@]}"; do
              if echo "$AVAILABLE_CHECKS" | grep -q "^$check$"; then
                REQUIRED_CHECKS+=("$check")
              fi
            done
            
            # If no preferred checks are available, wait for any checks that are running
            if [ ${#REQUIRED_CHECKS[@]} -eq 0 ]; then
              echo "No preferred checks found, waiting for any available checks to complete..."
              while IFS= read -r check; do
                REQUIRED_CHECKS+=("$check")
              done <<< "$AVAILABLE_CHECKS"
            fi
            
            echo "Required checks: ${REQUIRED_CHECKS[*]}"
            
            ALL_COMPLETE=true
            ALL_SUCCESS=true
            
            for check in "${REQUIRED_CHECKS[@]}"; do
              CHECK_STATE=$(echo "$CHECKS" | jq -r ".[] | select(.name == \"$check\") | .state // \"not_found\"")
              
              echo "  $check: state=$CHECK_STATE"
              
              if [ "$CHECK_STATE" = "not_found" ] || [ "$CHECK_STATE" = "PENDING" ] || [ "$CHECK_STATE" = "QUEUED" ] || [ "$CHECK_STATE" = "IN_PROGRESS" ]; then
                ALL_COMPLETE=false
              fi
              
              if [ "$CHECK_STATE" != "SUCCESS" ] && [ "$CHECK_STATE" != "not_found" ]; then
                ALL_SUCCESS=false
              fi
            done
            
            if [ "$ALL_COMPLETE" = "true" ]; then
              echo "All required checks have completed"
              echo "all_complete=true" >> $GITHUB_OUTPUT
              echo "all_success=$ALL_SUCCESS" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # Don't sleep on the last attempt
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Waiting $SLEEP_TIME seconds before next check..."
              sleep $SLEEP_TIME
            fi
          done
          
          echo "Timeout waiting for checks to complete"
          echo "all_complete=false" >> $GITHUB_OUTPUT
          exit 1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  merge-decision:
    runs-on: ubuntu-latest
    needs: wait-for-checks
    if: needs.wait-for-checks.outputs.all_checks_complete == 'true'
    
    steps:
      - name: Gather PR context
        id: pr-context
        run: |
          PR_NUMBER=${{ needs.wait-for-checks.outputs.pr_number }}
          echo "Gathering comprehensive PR context for PR #$PR_NUMBER..."
          
          # Get all check results
          echo "CHECK_RESULTS<<EOF" >> $GITHUB_OUTPUT
          gh pr checks $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json name,state,conclusion \
            | jq -r '.[] | "\(.name): \(.state) (\(.conclusion // "pending"))"' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Get PR metadata
          PR_DATA=$(gh pr view $PR_NUMBER \
            --repo ${{ github.repository }} \
            --json title,body,mergeable,mergeStateStatus,isDraft,author,baseRefName,headRefName,commits)
          
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "PR_MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')" >> $GITHUB_OUTPUT
          echo "PR_MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')" >> $GITHUB_OUTPUT
          echo "PR_IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')" >> $GITHUB_OUTPUT
          echo "PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')" >> $GITHUB_OUTPUT
          echo "BASE_BRANCH=$(echo "$PR_DATA" | jq -r '.baseRefName')" >> $GITHUB_OUTPUT
          echo "HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')" >> $GITHUB_OUTPUT
          
          # Check if this is a Release Please PR
          AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
          HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          IS_RELEASE_PLEASE="false"
          if [[ "$AUTHOR" == "app/github-actions" ]] && [[ "$HEAD_BRANCH" == release-please--* ]]; then
            IS_RELEASE_PLEASE="true"
            echo "Detected Release Please PR"
          fi
          echo "IS_RELEASE_PLEASE=$IS_RELEASE_PLEASE" >> $GITHUB_OUTPUT
          
          # Get detailed CI check information
          echo "üîç Gathering detailed CI check information..."
          
          # Get all checks summary
          ALL_CHECKS=$(gh pr checks $PR_NUMBER --repo ${{ github.repository }} --json name,state)
          
          # Key check states - be flexible about check names
          TEST_RESULT=$(echo "$ALL_CHECKS" | jq -r '.[] | select(.name == "test (20.x)" or .name == "CI / test (20.x)") | .state' | head -1)
          TEST_RESULT=${TEST_RESULT:-"PENDING"}
          
          SECURITY_RESULT=$(echo "$ALL_CHECKS" | jq -r '.[] | select(.name == "security" or .name == "CI / security") | .state' | head -1)
          SECURITY_RESULT=${SECURITY_RESULT:-"PENDING"}
          
          CLAUDE_RESULT=$(echo "$ALL_CHECKS" | jq -r '.[] | select(.name == "claude-review") | .state' | head -1)
          CLAUDE_RESULT=${CLAUDE_RESULT:-"PENDING"}
          
          VALIDATE_RESULT=$(echo "$ALL_CHECKS" | jq -r '.[] | select(.name == "validate-pr") | .state' | head -1)
          VALIDATE_RESULT=${VALIDATE_RESULT:-"PENDING"}
          
          # Get complete Claude review content from artifact file (preferred method)
          if [ "$CLAUDE_RESULT" = "SUCCESS" ]; then
            echo "üîç Loading Claude review from artifact file..."
            
            if [ -f "/tmp/claude-review-analysis.md" ]; then
              echo "‚úÖ Found Claude review analysis file"
              CLAUDE_REVIEW_CONTENT=$(cat /tmp/claude-review-analysis.md)
              FILE_SIZE=$(wc -c < /tmp/claude-review-analysis.md)
              echo "üìÑ Review file size: $FILE_SIZE characters"
              echo "üìù Review preview: ${CLAUDE_REVIEW_CONTENT:0:200}..."
              
              echo "CLAUDE_REVIEW_CONTENT<<EOF" >> $GITHUB_OUTPUT
              echo "$CLAUDE_REVIEW_CONTENT" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è Claude review file not found, falling back to comment parsing..."
              
              # Fallback: Get the most substantial Claude comment
              CLAUDE_REVIEW_COMMENT=$(gh pr view $PR_NUMBER \
                --repo ${{ github.repository }} \
                --json comments \
                --jq '.comments[] | select(.author.login == "claude" and (.body | length > 100)) | .body' \
                | tail -n 1)
              
              if [ -n "$CLAUDE_REVIEW_COMMENT" ] && [ "$CLAUDE_REVIEW_COMMENT" != "null" ]; then
                echo "‚úÖ Found Claude review comment as fallback (${#CLAUDE_REVIEW_COMMENT} characters)"
                echo "CLAUDE_REVIEW_CONTENT<<EOF" >> $GITHUB_OUTPUT
                echo "$CLAUDE_REVIEW_COMMENT" >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT
              else
                echo "‚ùå No Claude review content available"
                echo "CLAUDE_REVIEW_CONTENT=No detailed review content available - neither file nor comment found" >> $GITHUB_OUTPUT
              fi
            fi
          else
            echo "‚ö†Ô∏è Claude review not successful, no review content available"
            echo "CLAUDE_REVIEW_CONTENT=Claude review check did not complete successfully (status: $CLAUDE_RESULT)" >> $GITHUB_OUTPUT
          fi
          
          # Count passed/failed checks
          PASSED_CHECKS=$(echo "$ALL_CHECKS" | jq -r '.[] | select(.state == "SUCCESS") | .name' | wc -l)
          FAILED_CHECKS=$(echo "$ALL_CHECKS" | jq -r '.[] | select(.state == "FAILURE") | .name' | wc -l)
          TOTAL_CHECKS=$(echo "$ALL_CHECKS" | jq -r '.[] | .name' | wc -l)
          
          # Get failed check names if any
          FAILED_CHECK_NAMES=$(echo "$ALL_CHECKS" | jq -r '.[] | select(.state == "FAILURE") | .name' | tr '\n' ', ' | sed 's/,$//')
          
          echo "TEST_CONCLUSION=$TEST_RESULT" >> $GITHUB_OUTPUT
          echo "SECURITY_CONCLUSION=$SECURITY_RESULT" >> $GITHUB_OUTPUT
          echo "CLAUDE_REVIEW_CONCLUSION=$CLAUDE_RESULT" >> $GITHUB_OUTPUT
          echo "VALIDATE_CONCLUSION=$VALIDATE_RESULT" >> $GITHUB_OUTPUT
          echo "CHECKS_SUMMARY=$PASSED_CHECKS/$TOTAL_CHECKS checks passed" >> $GITHUB_OUTPUT
          echo "FAILED_CHECKS=$FAILED_CHECK_NAMES" >> $GITHUB_OUTPUT
          
          echo "üìä CI Summary: $PASSED_CHECKS passed, $FAILED_CHECKS failed out of $TOTAL_CHECKS total"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Download Claude review analysis
        id: download-review
        uses: actions/download-artifact@v4
        with:
          name: claude-review-analysis-${{ steps.pr-context.outputs.PR_NUMBER }}
          path: /tmp/
        continue-on-error: true

      - name: Make merge decision
        id: merge-decision
        uses: anthropics/claude-code-action@e26577a930883943cf9d90885cd1e8da510078dd # beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          use_sticky_comment: true
          
          direct_prompt: |
            You are an AI merge decision maker. Analyze the complete context below and decide whether this PR should be merged.

            ## PR Information
            - **Title**: ${{ steps.pr-context.outputs.PR_TITLE }}
            - **Author**: ${{ steps.pr-context.outputs.PR_AUTHOR }}
            - **Target Branch**: ${{ steps.pr-context.outputs.BASE_BRANCH }}
            - **PR Number**: #${{ steps.pr-context.outputs.PR_NUMBER }}
            - **Is Draft**: ${{ steps.pr-context.outputs.PR_IS_DRAFT }}
            - **Is Release Please PR**: ${{ steps.pr-context.outputs.IS_RELEASE_PLEASE }}
            - **Mergeable**: ${{ steps.pr-context.outputs.PR_MERGEABLE }}
            - **Merge State**: ${{ steps.pr-context.outputs.PR_MERGE_STATE }}

            ## CI/CD Check Results
            - **Overall Summary**: ${{ steps.pr-context.outputs.CHECKS_SUMMARY }}
            - **Tests**: ${{ steps.pr-context.outputs.TEST_CONCLUSION }}
            - **Security**: ${{ steps.pr-context.outputs.SECURITY_CONCLUSION }}
            - **Validation**: ${{ steps.pr-context.outputs.VALIDATE_CONCLUSION }}
            - **Claude Review**: ${{ steps.pr-context.outputs.CLAUDE_REVIEW_CONCLUSION }}
            - **Failed Checks**: ${{ steps.pr-context.outputs.FAILED_CHECKS }}

            ## Complete Claude Code Review Analysis
            **IMPORTANT: This is the full Claude review content that must guide your decision:**
            
            ${{ steps.pr-context.outputs.CLAUDE_REVIEW_CONTENT }}
            
            ## Your Task
            Based on the complete context above, **especially Claude's detailed review analysis**, decide whether this PR should be merged.

            **Decision Rules** (in priority order):
            1. **Claude Review Override**: If the Claude review above contains "DO NOT MERGE", "REJECT", or explicitly recommends against merging ‚Üí REJECT
            2. **Critical CI Failures**: If any critical CI checks failed ‚Üí REJECT
            3. **Release Please PRs**: If Release Please PR and all CI checks passed ‚Üí APPROVE
            4. **Regular PRs**: Follow Claude's review recommendations:
               - If Claude approves changes or finds no blocking issues ‚Üí APPROVE
               - If Claude identifies critical issues or concerns ‚Üí REJECT
               - If Claude requests changes ‚Üí REJECT
            5. **No Clear Guidance**: If unclear, err on the side of manual review ‚Üí REJECT

            **Critical**: Your decision must be based primarily on Claude's review content above. The CI status is secondary to Claude's analysis.

            **CRITICAL: You MUST respond with valid JSON in this exact format:**
            ```json
            {
              "decision": "APPROVE|REJECT",
              "reason": "Brief explanation of your decision based on Claude review and CI status",
              "critical_issues": ["list", "of", "any", "blocking", "issues"],
              "recommended_action": "auto-merge|manual-review|fix-issues"
            }
            ```

            **IMPORTANT**: After providing your analysis, also write your JSON decision to a file for the workflow to process:
            
            Create a file `/tmp/merge-decision.json` with your exact JSON decision using this command:
            ```bash
            echo '{"decision": "APPROVE", "reason": "Your reasoning here", "critical_issues": [], "recommended_action": "auto-merge"}' > /tmp/merge-decision.json
            ```
            
            Replace the values with your actual decision. This ensures the workflow can reliably access your decision.

      - name: Parse merge decision
        id: parse-decision
        run: |
          echo "üìã Parsing Claude's merge decision..."
          
          # First, try to read from the decision file that Claude should have created
          DECISION_JSON=""
          if [ -f "/tmp/merge-decision.json" ]; then
            echo "‚úÖ Found decision file, reading JSON..."
            DECISION_JSON=$(cat /tmp/merge-decision.json)
            echo "üìÑ Decision from file: $DECISION_JSON"
          else
            echo "‚ö†Ô∏è No decision file found, falling back to comment parsing..."
            
            # Fallback: Get Claude comment with better filtering
            CLAUDE_DECISION_COMMENT=$(gh pr view ${{ steps.pr-context.outputs.PR_NUMBER }} \
              --repo ${{ github.repository }} \
              --json comments \
              --jq '.comments[] | select(.author.login == "claude" and (.body | contains("\"decision\"") and (contains("APPROVE") or contains("REJECT")))) | .body' \
              | head -1)
            
            if [ -z "$CLAUDE_DECISION_COMMENT" ] || [ "$CLAUDE_DECISION_COMMENT" = "null" ]; then
              echo "‚ùå No decision comment found, trying latest Claude comment..."
              CLAUDE_DECISION_COMMENT=$(gh pr view ${{ steps.pr-context.outputs.PR_NUMBER }} \
                --repo ${{ github.repository }} \
                --json comments \
                --jq '.comments[] | select(.author.login == "claude") | .body' \
                | tail -1)
            fi
            
            # Extract JSON from the comment (handle markdown code blocks)
            DECISION_JSON=$(echo "$CLAUDE_DECISION_COMMENT" | sed -n '/```json/,/```/p' | sed '1d;$d' | tr -d '\n' | head -1)
            if [ -z "$DECISION_JSON" ]; then
              # Fallback: try raw JSON extraction
              DECISION_JSON=$(echo "$CLAUDE_DECISION_COMMENT" | grep -o '{[^}]*"decision"[^}]*}' | head -1)
            fi
            
            if [ -z "$DECISION_JSON" ] || [ "$DECISION_JSON" = "null" ]; then
              echo "‚ùå Failed to extract JSON decision from Claude's comment"
              echo "Raw comment: $CLAUDE_DECISION_COMMENT"
              exit 1
            fi
            
            echo "üìÑ Decision from comment: $DECISION_JSON"
          fi
          
          # Parse the decision
          DECISION=$(echo "$DECISION_JSON" | jq -r '.decision // "UNKNOWN"')
          REASON=$(echo "$DECISION_JSON" | jq -r '.reason // "No reason provided"')
          CRITICAL_ISSUES=$(echo "$DECISION_JSON" | jq -r '.critical_issues // [] | join(", ")')
          RECOMMENDED_ACTION=$(echo "$DECISION_JSON" | jq -r '.recommended_action // "manual-review"')
          
          echo "üéØ Decision: $DECISION"
          echo "üìù Reason: $REASON"
          echo "‚ö†Ô∏è Critical Issues: $CRITICAL_ISSUES"
          echo "üîÑ Recommended Action: $RECOMMENDED_ACTION"
          
          # Export for next steps
          echo "DECISION=$DECISION" >> $GITHUB_OUTPUT
          echo "REASON=$REASON" >> $GITHUB_OUTPUT
          echo "CRITICAL_ISSUES=$CRITICAL_ISSUES" >> $GITHUB_OUTPUT
          echo "RECOMMENDED_ACTION=$RECOMMENDED_ACTION" >> $GITHUB_OUTPUT
          
          # Fail the step if decision is REJECT
          if [ "$DECISION" = "REJECT" ]; then
            echo "‚ùå Claude rejected this PR"
            exit 1
          elif [ "$DECISION" = "APPROVE" ]; then
            echo "‚úÖ Claude approved this PR"
          else
            echo "‚ùì Unknown decision: $DECISION"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Apply approved merge decision
        if: steps.parse-decision.outputs.DECISION == 'APPROVE'
        run: |
          echo "‚úÖ Applying approved merge decision..."
          echo "üìù Reason: ${{ steps.parse-decision.outputs.REASON }}"
          
          # Auto-merge if this is a Release Please PR and recommended action is auto-merge
          if [ "${{ steps.pr-context.outputs.IS_RELEASE_PLEASE }}" = "true" ] && [ "${{ steps.parse-decision.outputs.RECOMMENDED_ACTION }}" = "auto-merge" ]; then
            echo "üöÄ Auto-merging Release Please PR..."
            
            if gh pr merge ${{ steps.pr-context.outputs.PR_NUMBER }} \
              --repo ${{ github.repository }} \
              --auto \
              --squash; then
              echo "‚úÖ Auto-merge enabled successfully"
            else
              echo "::warning::Failed to enable auto-merge. PR may need manual merge."
            fi
          else
            echo "üìã PR approved but requires manual merge (action: ${{ steps.parse-decision.outputs.RECOMMENDED_ACTION }})"
          fi
          
          # Create success status (truncate description to 140 chars max)
          REASON="${{ steps.parse-decision.outputs.REASON }}"
          DESCRIPTION="Claude AI approved: ${REASON:0:120}"  # Leave room for prefix
          gh api repos/${{ github.repository }}/statuses/${{ github.event.pull_request.head.sha || github.sha }} \
            -f state=success \
            -f description="$DESCRIPTION" \
            -f context="merge-decision" 2>/dev/null || echo "::warning::Status creation failed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Handle rejected merge decision
        if: failure()
        run: |
          echo "‚ùå PR rejected for merging"
          if [ -n "${{ steps.parse-decision.outputs.REASON }}" ]; then
            echo "üìù Reason: ${{ steps.parse-decision.outputs.REASON }}"
          fi
          if [ -n "${{ steps.parse-decision.outputs.CRITICAL_ISSUES }}" ]; then
            echo "‚ö†Ô∏è Critical Issues: ${{ steps.parse-decision.outputs.CRITICAL_ISSUES }}"
          fi
          
          # Create failure status (truncate description to 140 chars max)
          DESCRIPTION="Claude AI rejected PR"
          if [ -n "${{ steps.parse-decision.outputs.REASON }}" ]; then
            REASON="${{ steps.parse-decision.outputs.REASON }}"
            DESCRIPTION="${DESCRIPTION}: ${REASON:0:115}"  # Leave room for prefix
          fi
          
          gh api repos/${{ github.repository }}/statuses/${{ github.event.pull_request.head.sha || github.sha }} \
            -f state=failure \
            -f description="$DESCRIPTION" \
            -f context="merge-decision" 2>/dev/null || echo "::warning::Status creation failed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}